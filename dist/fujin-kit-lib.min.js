(function () {
  'use strict';

  const theme = {
      colors: {
      
      text: '#10375C',        // Dark Blue (Text Color)
          background: '#F4F6FF',  // Soft Light Blue (Background Color)
      success: '#28a745',      // Success Green
      error: '#dc3545',        // Error Red
      info: '#17a2b8',         // Info Blue
          warning: '#ffc107',  
      
          primary: '#b2182b',
  secondary: '#f8e7ea',
          tertiary: '#3458b9',
          label: '#445464'
    

      },
      spacing: {

      },
      fonts: {
          m: '14px',
          s: '12px',
          l: '16px',
          xl: '20px',
          xxl: '24px'
      },
      borders: {
          s: '10px',
          m: '14px',
          l: '18px'
      }
      
    // Future theme properties (fonts, spacing, etc.) can be added here
  };

  class Button extends HTMLElement {
      constructor() {
          super();
          const { colors, fonts } = theme;
          const shadow = this.attachShadow({ mode: 'open' });
        
          // attributes
          /**
           * 
           * type: 'primary' | 'secondary' | 'outlined' | 'text' | 'success' | 'error' | 'info' | 'warning'
           * label: string
           * size: 'medium' | 'small' | 'large'
           * rounded: boolean
           * disabled: boolean
           */
          const type = this.getAttribute('type') || 'primary';
          const label = this.textContent.trim() || 'Button';
          const size = this.getAttribute('size') || 'medium';
          const disabled = this.hasAttribute('disabled') || false;
          // separate variant will require nested styling
          // const variant = this.getAttribute('variant') || 'default';



          const style = document.createElement('style');
          style.textContent = `
      .btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: ${fonts.m};
        font-weight: 500;
        line-height: 1.5;
        text-align: center;
        text-decoration: none;
        white-space: nowrap;
        cursor: pointer;
        border: none;
        padding: 8px 16px;
        transition: all 0.2s ease-in-out;
      }
      .primary {
        background-color: ${colors.primary};
        color: white;
                              box-shadow: 4px 4px 0px ${colors.secondary};
      }
      .secondary {
        background-color: ${colors.secondary};
        color: ${colors.primary};
                                      box-shadow: 4px 4px 0px ${colors.primary};

      }
      .outlined {
        border: 1px solid ${colors.primary};
        background: white;
        color: ${colors.primary};
                                              box-shadow: 4px 4px 0px ${colors.primary};

      }
      .text {
        background: none;
        color: ${colors.text};
        text-decoration: underline;
      }
        .success {
         background: ${colors.success};
         color: white;
                                               box-shadow: 4px 4px 0px #ccc;

        }
         .info {
          background: ${colors.info};
          color: white;
          box-shadow: 4px 4px 0px #ccc;
         }
          .warning {
          background: ${colors.warning};
          color: white;
          box-shadow: 4px 4px 0px #ccc;
          }
          .error {
          background: ${colors.error};
          color: white;
          box-shadow: 4px 4px 0px #ccc;
          }
          .small {
            font-size: ${fonts.s};
            padding: 3px 9px;
          }
            .large {
            font-size: ${fonts.l};
            padding: 5px 25px;
            }

            .disabled {
             opacity: 0.8;
             cursor: not-allowed;
             
            }
      .btn:hover {
        opacity: 0.8;
      }
    `;

      const btn = document.createElement('button');
          btn.textContent = label;
          btn.disabled = disabled;
      btn.className = `btn ${type} ${size} ${disabled ? 'disabled' : ''}`;

          btn.addEventListener('click', (e) => {
              if (!disabled) {
                  e.stopPropagation();
                  this.dispatchEvent(new Event('click'));
              }
  });
          
      shadow.appendChild(style);
      shadow.appendChild(btn);
    }
  }

  customElements.define('fj-button', Button);

  class Text extends HTMLElement {
      constructor() {
          super();
          const { colors, fonts } = theme;
          const shadow = this.attachShadow({ mode: 'open' });
        
          // attributes
          /**
           * bold: boolean
           * semiBold: boolean
           * italic: boolean
           * underline: boolean
           * type: 'default' | 'h1' | 'h2' | 'h3' | 'label'
           * variant: 'default' | 'success' | 'warning' | 'info' | 'error'
           */
          const variant = this.getAttribute('variant') || 'default';
          const type = this.getAttribute('type') || 'default';
          const italic = this.hasAttribute('italic') || false;
          const underline = this.hasAttribute('underline') || false;
          const bold = this.hasAttribute('bold') || false;
          const semiBold = this.hasAttribute('semiBold') || false;
          
          const label = this.textContent.trim() || 'Text';



          const style = document.createElement('style');
          style.textContent = `

      .text {
       font-size: ${fonts.m};
       color: ${colors.text};
      }
       .success {
        color: ${colors.success};
       }
        .warning {
        color: ${colors.warning};
        }
        .info {
        color: ${colors.info};
        }
        .error {
        color: ${colors.error};
        }
        .h1 {
        font-size: ${fonts.xxl};
        font-weight: 700;
        }


.h2 {
        font-size: ${fonts.xl};
        font-weight: 700;
        }

.h3 {
        font-size: ${fonts.l};
        font-weight: 700;
        }

        .label {
            font-size: ${fonts.s};
            color: ${colors.label};
        }

        .bold {
        font-weight: 700;
        }

        .semiBold {
        font-weight: 600;
        }

        .italic {
        font-style: italic;
        }
        .underline {
        text-decoration: underline;
        }
    `;

      const text = document.createElement('span');
          text.textContent = label;
          
      text.className = `text ${variant} ${type} ${italic ? 'italic' : ''} ${underline ? 'underline' : ''} ${semiBold ? 'semiBold' : ''} ${bold ? 'bold' : ''}`;
      
          
      shadow.appendChild(style);
      shadow.appendChild(text);
    }
  }

  customElements.define('fj-text', Text);

  class Avatar extends HTMLElement {
      static get observedAttributes() {
          return ['url', 'text', 'shape', 'size', 'background'];
      }

      constructor() {
          super();
          this.shadow = this.attachShadow({ mode: 'open' });
          this.render();
      }

      attributeChangedCallback() {
          this.render();
      }

      getTextColor(bgHex = '#f8e7ea') {
          const hex = bgHex.replace('#', '');
          const r = parseInt(hex.substring(0, 2), 16);
          const g = parseInt(hex.substring(2, 4), 16);
          const b = parseInt(hex.substring(4, 6), 16);
          const brightness = (r + g + b) / 3;
          return brightness > 128 ? '#172b4d' : '#f8e7ea';
      }

      render() {
          const imageUrl = this.getAttribute('url');
          const text = this.getAttribute('text');
          const shape = this.getAttribute('shape') || 'circle';
          const size = this.getAttribute('size') || 'medium';
          const background = this.getAttribute('background') || '#f8e7ea';

          this.shadow.innerHTML = `
            <style>
                .avatar {
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    overflow: hidden;
                    background-color: ${background};
                    width: 48px;
                    height: 48px;
                }
                .avatar__image {
                    width: 100%;
                }
                .avatar__circle { border-radius: 50%; }
                .avatar__rounded { border-radius: 8px; }
                .avatar__square { border-radius: 0; }
                .avatar__small { width: 24px; height: 24px; }
                .avatar__large { width: 64px; height: 64px; }
                .avatar__text {
                    font-size: 24px;
                    color: ${this.getTextColor(background)};
                }
                .avatar__text__small { font-size: 18px; }
                .avatar__text__large { font-size: 32px; }
            </style>
            <div class="avatar avatar__${shape} avatar__${size}">
                ${imageUrl 
                    ? `<img src="${imageUrl}" alt="${text || ''}" class="avatar__image" />`
                    : text 
                        ? `<span class="avatar__text avatar__text__${size}">${text}</span>`
                        : ''
                }
            </div>
        `;
      }
  }

  customElements.define('fj-avatar', Avatar);

  class Breadcrumb extends HTMLElement {
      static get observedAttributes() {
        return ['items', 'separator'];
      }
    
      constructor() {
        super();
        this.shadow = this.attachShadow({ mode: 'open' });
        this.showMenu = null;  // Store the index of the open menu, or null if no menu is open
        this.selectedMenuItem = null;
        this.render();
    
        // Bind event listeners for detecting click outside
        this.handleClickOutside = this.handleClickOutside.bind(this);
      }
    
      // Getter and Setter for 'items'
      get items() {
        return this._items || [];
      }
    
      set items(value) {
        if (Array.isArray(value)) {
          this._items = value;
          this.render();
        } else {
          console.error('fj-breadcrumb: items must be an array');
        }
      }
    
      // Getter and Setter for 'separator'
      get separator() {
        return this.getAttribute('separator') || '/';
      }
    
      set separator(value) {
        this.setAttribute('separator', value);
        this.render();
      }
    
      // connectedCallback is called when the component is connected to the DOM
      connectedCallback() {
        this.render();
        document.addEventListener('click', this.handleClickOutside);
      }
    
      // disconnectedCallback to remove the event listener
      disconnectedCallback() {
        document.removeEventListener('click', this.handleClickOutside);
      }
    
      // Handle click outside to close the menu
      handleClickOutside(event) {
        // If the click is outside the shadow root of the breadcrumb, close the menu
        if (!this.shadowRoot.contains(event.target)) {
          this.showMenu = null;  // Close the menu when clicked outside
          this.render();
        }
      }
    
      // handle menu item click
      handleMenuItemClick(menuItem, event) {
        event.preventDefault(); // Prevent bubbling up to document
        this.selectedMenuItem = menuItem;
        this.showMenu = null; // Close the menu after selecting an item
        this.dispatchEvent(new CustomEvent('menuItemSelect', {
          detail: menuItem,
          bubbles: true,
        }));
        this.render();
      }
    
      // render the breadcrumb HTML
      render() {
        const separator = this.separator;
        const rawItems = this.getAttribute('items') || '[]';
        let items;
    
        try {
          items = JSON.parse(rawItems);
        } catch (e) {
          console.error('Invalid JSON for Breadcrumb items:', e);
          items = [];
        }
    
        this.shadow.innerHTML = `
        <style>
          nav {
            display: flex;
            align-items: center;
          }
  
          .custom_breadcrumb {
            display: flex;
            gap: 10px;
            list-style-type: none;
            padding: 0;
            margin: 0;
          }
  
          .custom_breadcrumb a {
            color: inherit;
            text-decoration: none;
          }
  
          .custom_breadcrumb a:hover {
            text-decoration: underline;
          }
  
          .menu_container {
            position: relative;
            padding: 0 0 4px 0;
          }
  
          .menu {
            position: absolute;
            box-shadow: 0 3px 6px -4px rgba(0, 0, 0, 0.12),
                        0 6px 16px 0 rgba(0, 0, 0, 0.08),
                        0 9px 28px 8px rgba(0, 0, 0, 0.05);
            border-radius: 2px;
            background-color: #fff;
            padding: 4px 0;
            cursor: pointer;
            z-index: 10;
          }
  
          .menu div {
            padding: 4px 8px;
          }
  
          .menu div:hover {
            background-color: rgba(191, 191, 191, 0.1);
          }
  
          li {
            list-style: none;
          }
        </style>
  
        <nav aria-label="breadcrumb">
          <ul class="custom_breadcrumb">
            ${
              items.map((item, index) => `
                <li>
                  ${
                    index === items.length - 1 && !item.menu
                      ? `<fj-text bold>
                          <span tabindex="0" role="button">
                            ${item.title}
                          </span>
                        </fj-text>`
                      : item.menu?.length
                        ? `
                          <div class="menu_container">
                            <div class="menu_trigger" role="button" tabindex="0" 
                                 onclick="this.getRootNode().host.toggleMenu(${index}, event)">
                              <span>${this.selectedMenuItem?.label || item.title}</span> ▼
                            </div>
                            ${this.showMenu === index
                              ? `<div class="menu">
                                  ${item.menu.map(menuItem => `
                                    <div role="button" tabindex="0">
                                      ${
                                        menuItem.path
                                          ? `<a href="${menuItem.path}" tabindex="0" role="link"
                                               onclick="this.getRootNode().host.handleMenuItemClick(${JSON.stringify(menuItem)}, event)">
                                                ${menuItem.label}
                                             </a>`
                                          : `<span tabindex="0"
                                               onclick="this.getRootNode().host.handleMenuItemClick(${JSON.stringify(menuItem)}, event)">
                                                ${menuItem.label}
                                             </span>`
                                      }
                                    </div>
                                  `).join('')}
                                </div>`
                              : ''
                            }
                          </div>
                        `
                        : `<a href="${item.path || '#'}" tabindex="0" role="link">${item.title}</a>`
                  }
                </li>
                ${index !== items.length - 1 ? `<span>${separator}</span>` : ''}
              `).join('')
            }
          </ul>
        </nav>
      `;
      }
    
      // toggle the visibility of the nested menu
      toggleMenu(index, event) {
        // Toggle the menu visibility state
        event.stopPropagation();
        this.showMenu = this.showMenu === index ? null : index;
        this.render();
      }
    }
    
    // Define the custom element
    customElements.define('fj-breadcrumb', Breadcrumb);

  const { colors: colors$4, fonts: fonts$2 } = theme;

  class FjCheckbox extends HTMLElement {
    static get observedAttributes() {
      return ['checked', 'disabled', 'size', 'indeterminate'];
    }

    constructor() {
      super();
      this.attachShadow({ mode: 'open' });
      this._checked = false;
      this._indeterminate = false;
      this.render();
    }

    get checked() {
      return this.hasAttribute('checked');
    }

    set checked(value) {
      if (value) {
        this.setAttribute('checked', '');
      } else {
        this.removeAttribute('checked');
      }
    }

    get indeterminate() {
      return this.hasAttribute('indeterminate');
    }

    set indeterminate(value) {
      if (value) {
        this.setAttribute('indeterminate', '');
      } else {
        this.removeAttribute('indeterminate');
      }
    }

    attributeChangedCallback() {
      this.render();
    }

    connectedCallback() {
      this.render();
    }

    render() {
      const checked = this.checked;
      const disabled = this.hasAttribute('disabled');
      const size = this.getAttribute('size') || 'medium';
      const indeterminate = this.indeterminate;

      this.shadowRoot.innerHTML = `
      <style>
        .wrapper {
          display: flex;
          align-items: center;
          margin-right: 8px;
          opacity: ${disabled ? '0.5' : '1'};
          cursor: ${disabled ? 'not-allowed' : 'pointer'};
          font-size: ${size === 'medium' ? fonts$2.m : size === 'small' ? fonts$2.s : fonts$2.xl};
        }
        input {
          margin: 4px;
          width: 16px;
          height: 16px;
          border-radius: 0;
                box-shadow: 2px 2px 0px #ccc;

        }
        input:checked {
          accent-color: ${colors$4.primary};
        }
        label {
          color: ${colors$4.text};
          cursor: pointer;
        }
      </style>
      <div class="wrapper">
        <input type="checkbox" ${checked ? 'checked' : ''} ${disabled ? 'disabled' : ''}>
        <label><slot></slot></label>
      </div>
    `;

      const input = this.shadowRoot.querySelector('input');
      input.indeterminate = indeterminate;

      input.onclick = e => e.stopPropagation();

      input.onchange = e => {
        this.checked = e.target.checked;
        this.dispatchEvent(
          new CustomEvent('change', {
            detail: { checked: e.target.checked },
            bubbles: true,
          })
        );
      };
    }
  }

  customElements.define('fj-checkbox', FjCheckbox);

  class FjCheckboxGroup extends HTMLElement {
      static get observedAttributes() {
        return ['disabled', 'orientation', 'size'];
      }
    
      constructor() {
        super();
        this.attachShadow({ mode: 'open' });
        this.render();
      }
    
      connectedCallback() {
        this.addEventListener('change', this.handleChange.bind(this));
      }
    
      disconnectedCallback() {
        this.removeEventListener('change', this.handleChange.bind(this));
      }
    
      attributeChangedCallback() {
        this.render();
      }
    
      handleChange(event) {
        const checkboxes = this.querySelectorAll('fj-checkbox');
        const selectedValues = [];
        checkboxes.forEach(checkbox => {
          if (checkbox.checked) {
            selectedValues.push(checkbox.getAttribute('value') || checkbox.innerText.trim());
          }
        });
    
        this.dispatchEvent(
          new CustomEvent('groupChange', {
            detail: { selectedValues, event },
            bubbles: true,
          })
        );
      }
    
      render() {
        const orientation = this.getAttribute('orientation') || 'vertical';
        const size = this.getAttribute('size') || 'medium';
        const disabled = this.hasAttribute('disabled');
    
        this.shadowRoot.innerHTML = `
        <style>
          .group {
            display: flex;
            flex-direction: ${orientation === 'horizontal' ? 'row' : 'column'};
          }
        </style>
        <div class="group">
          <slot></slot>
        </div>
      `;
    
        const slot = this.shadowRoot.querySelector('slot');
        slot.addEventListener('slotchange', () => {
          const nodes = slot.assignedElements();
          nodes.forEach(child => {
            if (disabled) {
              child.setAttribute('disabled', '');
            }
            if (!child.hasAttribute('size')) {
              child.setAttribute('size', size);
            }
          });
        });
      }
    }
    
    customElements.define('fj-checkbox-group', FjCheckboxGroup);

  class FjChip extends HTMLElement {
      static get observedAttributes() {
        return ['type', 'bold'];
      }
    
      constructor() {
        super();
        this.attachShadow({ mode: 'open' });
      }
    
      attributeChangedCallback() {
        this.render();
      }
    
      connectedCallback() {
        this.render();
      }
    
      render() {
        const type = this.getAttribute('type') || 'info';
        const isBold = this.hasAttribute('bold');
    
        let bgColor = '#e0f3ff'; // default info
        let fontColor = '#0077cc';
    
        if (type === 'success') {
          bgColor = '#e0ffe8';
          fontColor = '#1a7f37';
        } else if (type === 'error') {
          bgColor = '#ffe8e8';
          fontColor = '#cc1f1a';
        } else if (type === 'warning') {
          bgColor = '#fff7e0';
          fontColor = '#b38600';
        }
    
        this.shadowRoot.innerHTML = `
        <style>
          .chip {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
                  box-shadow: 2px 2px 0px #ccc;

            width: fit-content;
            background-color: ${bgColor};
            color: ${fontColor};
            font-size: 14px;
            ${isBold ? 'font-weight: bold;' : ''}
          }
          .icon {
            display: flex;
            align-items: center;
          }
        </style>
        <div class="chip">
          <slot name="icon"></slot>
          <slot></slot>
        </div>
      `;
      }
    }
    
    customElements.define('fj-chip', FjChip);

  class FjDivider extends HTMLElement {
      static get observedAttributes() {
        return ['orientation', 'variant', 'thickness'];
      }
    
      constructor() {
        super();
        this.attachShadow({ mode: 'open' });
      }
    
      attributeChangedCallback() {
        this.render();
      }
    
      connectedCallback() {
        this.render();
      }
    
      render() {
        const orientation = this.getAttribute('orientation') || 'horizontal';
        const variant = this.getAttribute('variant') || 'solid';
        const thickness = this.getAttribute('thickness') || '1px';
    
        const isHorizontal = orientation === 'horizontal';
        const borderStyle = variant;
    
        this.shadowRoot.innerHTML = `
        <style>
          .divider {
            ${isHorizontal 
              ? `width: 100%; border-top: ${thickness} ${borderStyle} #ccc;` 
              : `height: 100%; border-left: ${thickness} ${borderStyle} #ccc;`
            }
          }
        </style>
        <div class="divider"></div>
      `;
      }
    }
    
    customElements.define('fj-divider', FjDivider);

  const { colors: colors$3 } = theme;

  class FJSlider extends HTMLElement {
    static get observedAttributes() {
      return ['value', 'min', 'max', 'display-suffix'];
    }

    constructor() {
      super();
      this.attachShadow({ mode: 'open' });

      this.min = 0;
      this.max = 100;
      this.value = 50;
      this.displaySuffix = '%';

      this.padding = 8; // extra space around the knob
      this.knobSize = 16;

      this.handleInputChange = this.handleInputChange.bind(this);
    }

    connectedCallback() {
      this.render();
    }

    attributeChangedCallback(name, oldValue, newValue) {
      if (oldValue === newValue) return;

      if (name === 'min' || name === 'max' || name === 'value') {
        this[name] = parseFloat(newValue);
      } else if (name === 'display-suffix') {
        this.displaySuffix = newValue;
      }

      this.updateUI();
    }

    handleInputChange(e) {
      const newValue = parseFloat(e.target.value);
      this.value = newValue;
      this.setAttribute('value', newValue);

      this.dispatchEvent(new CustomEvent('change', {
        detail: { value: newValue },
        bubbles: true,
        composed: true,
      }));

      this.updateUI();
    }

    updateUI() {
      const svg = this.shadowRoot.querySelector('svg');
      const track = this.shadowRoot.querySelector('.filledTrack');
      const knob = this.shadowRoot.querySelector('.knob');
      const label = this.shadowRoot.querySelector('.valueLabel');

      if (!svg || !knob) return;

      const svgWidth = svg.clientWidth || 1; // avoid division by zero
      const percent = (this.value - this.min) / (this.max - this.min);

      const availableWidth = svgWidth - 2 * (this.padding + this.knobSize / 2);
      const xPosition = this.padding + (this.knobSize / 2) + percent * availableWidth - (this.knobSize / 2);

      if (track) track.setAttribute('width', `${percent * 100}%`);
      knob.setAttribute('x', `${xPosition}`);
      if (label) label.textContent = `${this.value} ${this.displaySuffix}`;
    }

    render() {
      const percent = (this.value - this.min) / (this.max - this.min);
      const estimatedWidth = 300; // estimated width for initial guess
      const availableWidth = estimatedWidth - 2 * (this.padding + this.knobSize / 2);
      const estimatedX = this.padding + (this.knobSize / 2) + percent * availableWidth - (this.knobSize / 2);

      this.shadowRoot.innerHTML = `
      <style>
        :host { display: block; max-width: 400px; position: relative; text-align: center; }
        .sliderContainer { width: 100%; position: relative; }
        .track { width: 100%; fill: lightgrey; height: 4px; }
        .filledTrack { fill: ${colors$3.primary}; height: 4px; }
        .knob { cursor: pointer; stroke: ${colors$3.primary}; fill: lightgrey; stroke-width: 3px; }
        .knob:hover { transform: scale(1.3); }
        .hiddenInput { width: 100%; position: absolute; left: 0; top: 0; opacity: 0; height: 30px; cursor: pointer; }
        .valueLabel { position: absolute; top: 17px; left: calc(50% - 25px); width: fit-content; text-align: center; }
      </style>

      <div class="sliderContainer">
        <svg width="100%" height="30">
          <rect x="0" y="10" width="100%" class="track" />
          <rect x="0" y="10" width="${percent * 100}%" class="filledTrack" />
          <rect 
            y="5" 
            width="${this.knobSize}" 
            height="${this.knobSize}" 
            x="${estimatedX}" 
            class="knob"
          ></rect>
        </svg>

        <input 
          type="range"
          min="${this.min}"
          max="${this.max}"
          value="${this.value}"
          step="0.01"
          class="hiddenInput" 
        />
        <div class="valueLabel">${this.value} ${this.displaySuffix}</div>
      </div>
    `;

      this.shadowRoot.querySelector('input')
        .addEventListener('input', this.handleInputChange);

      requestAnimationFrame(() => this.updateUI()); // accurate positioning after DOM paints
    }
  }

  customElements.define('fj-slider', FJSlider);

  const {colors: colors$2, fonts: fonts$1} = theme;

  class FJSwitch extends HTMLElement {
      static get observedAttributes() {
        return ['value', 'size'];
      }
    
      constructor() {
        super();
        this.attachShadow({ mode: 'open' });
        this.value = false;
        this.size = 'medium';
      }
    
      connectedCallback() {
        this.render();
        this.updateInnerPosition();
      }
    
      attributeChangedCallback(name, oldValue, newValue) {
        if (name === 'value') {
          this.value = newValue === 'true';
          this.updateInnerPosition();
        }

        if(name === 'size'){
          this.size = newValue;
        }
      }
    
      updateInnerPosition() {
          const inner = this.shadowRoot.querySelector('.switch__inner');
          const container = this.shadowRoot.querySelector('.switch');
        
          if (inner) {
            const selfHeight = inner.offsetHeight;
            const left = this.value
              ? `calc(100% - ${selfHeight}px - 2px)`
              : '2px';
            inner.style.left = left;
          }
        
          if (container) {
            container.classList.remove('switch__on', 'switch__off');
            container.classList.add(this.value ? 'switch__on' : 'switch__off');
          }
        }
    
      render() {
          this.shadowRoot.innerHTML = `
          <style>
            :host {
              display: inline-block;
            }
      
            .switch {
              position: relative;
              background-color: #ccc;
              transition: all 0.3s ease;
              margin-right: 3px;
            }

            .switch__off {
               background: #ccc;
            }
      
            .switch__on {
              background-color: ${colors$2.primary};
            }
      
            .switch__inner {
              position: absolute;
              top: 2px;
              background-color: #fff;
              transition: all 0.3s ease;
              height: calc(100% - 4px);
              aspect-ratio: 1/1;
            }
      
            .switch__disabled {
              opacity: 0.5;
            }
      
            input[type='checkbox'] {
              position: absolute;
              width: 100%;
              height: 100%;
              margin: 0;
              opacity: 0;
              cursor: pointer;
            }
      
            input[type='checkbox'].checkbox__disabled {
              cursor: not-allowed;
            }
      
            .switch__medium {
              width: calc((${fonts$1.xl} * 2) + 4px);
              height: calc((${fonts$1.xl} + 2px));
            }
      
            .switch__small {
              width: calc(${fonts$1.m} * 2);
              height: ${fonts$1.l};
            }
          </style>
      
          <div class="switch switch__${this.size} ${this.value ? 'switch__on' : 'switch__off'}">
            <input type="checkbox" ${this.value ? 'checked' : ''} />
            <span class="switch__inner"></span>
          </div>
        `;
        
          this.shadowRoot.querySelector('input')
            .addEventListener('change', (e) => {
              this.value = e.target.checked;
              this.setAttribute('value', String(this.value));
              this.updateInnerPosition();
        
              this.dispatchEvent(new CustomEvent('change', {
                detail: { value: this.value },
                bubbles: true,
                composed: true
              }));
            });
        }
        
    }
    
    customElements.define('fj-switch', FJSwitch);

  class Card extends HTMLElement {
      constructor() {
          super();
          const { colors, fonts, borders } = theme;
          const shadow = this.attachShadow({ mode: 'open' });
        
          // attributes
          /**
           * type: 'default' | 'success' | 'error' | 'info' | 'warning'
           */

          const type = this.getAttribute('type') || 'default';
          
          const children = this.innerHTML || 'Card';



          const style = document.createElement('style');
          style.textContent = `
      .card {
      display: flex;
      flex-direction: column;
      background: white;
      justify-content: center;
      border: 1px solid #aaa;
      box-shadow: 4px 4px 0px #ccc;
      padding: 16px;
      transition: 0.3s;
      }
       .success {
        border-color: ${colors.success};
              box-shadow: 4px 4px 0px ${colors.success};

       }
        .warning {
        border-color: ${colors.warning};
              box-shadow: 4px 4px 0px ${colors.warning};

        }
        .info {
        border-color: ${colors.info};
              box-shadow: 4px 4px 0px ${colors.info};

        }
        .error {
        border-color: ${colors.error};
              box-shadow: 4px 4px 0px  ${colors.error};

        }
    `;

      const card = document.createElement('div');
          card.innerHTML = children;
          
      card.className = `card ${type}`;
      
          
      shadow.appendChild(style);
      shadow.appendChild(card);
    }
  }

  customElements.define('fj-card', Card);

  class FJSkeleton extends HTMLElement {
      static get observedAttributes() {
        return ['rect', 'lines', 'avatar'];
      }
    
      constructor() {
        super();
        this.attachShadow({ mode: 'open' });
        this.rect = false;
        this.lines = 3;
        this.avatar = false;
      }
    
      connectedCallback() {
        this.render();
      }
    
      attributeChangedCallback(name, oldValue, newValue) {
        if (name === 'rect') this.rect = this.hasAttribute('rect');
        if (name === 'avatar') this.avatar = this.hasAttribute('avatar');
        if (name === 'lines') this.lines = parseInt(newValue) || 3;
    
        this.render();
      }
    
      render() {
        const skeletonClass = this.rounded ? 'rounded' : '';
        const lines = this.rect ? 1 : this.lines;
    
        let avatarHTML = '';
        if (this.avatar) {
          avatarHTML = `<div class="avatar ${skeletonClass}"></div>`;
        }
    
        let linesHTML = '';
        for (let i = 0; i < lines; i++) {
          linesHTML += `<div class="line ${skeletonClass}"></div>`;
        }
    
        this.shadowRoot.innerHTML = `
        <style>
          :host {
            display: block;
          }
          .skeleton-container {
            display: flex;
            align-items: center;
            gap: 10px;
          }
          .avatar {
            width: 40px;
            height: 40px;
            flex-shrink: 0;
                        animation: pulse 1.5s infinite ease-in-out;

          }
          .line {
            height: 12px;
                       animation: pulse 1.5s infinite ease-in-out;

            flex-grow: 1;
            margin: 5px 0;
          }
          .rect .line {
            width: 100%;
            height: 100px;
                        animation: pulse 1.5s infinite ease-in-out;

          }
          @keyframes pulse {
            0% { background-color: #eee; }
            50% { background-color: #ddd; }
            100% { background-color: #eee; }
          }
        </style>
        <div class="skeleton-container ${this.rect ? 'rect' : ''}">
          ${avatarHTML}
          <div style="flex-grow:1;">
            ${linesHTML}
          </div>
        </div>
      `;
      }
    }
    
    customElements.define('fj-skeleton', FJSkeleton);

  const {colors: colors$1} = theme;
  class FJImageLoader extends HTMLElement {
      static get observedAttributes() {
        return ['src', 'alt', 'height', 'width'];
      }
    
      constructor() {
        super();
        this.attachShadow({ mode: 'open' });
        this.src = '';
        this.alt = '';
        this.height = '100%';
        this.width = '100%';
        this.isLoaded = false;
      }
    
      connectedCallback() {
        this.render();
      }
    
      attributeChangedCallback(name, oldValue, newValue) {
        if (name === 'src') this.src = newValue;
        if (name === 'alt') this.alt = newValue;
        if (name === 'height') this.height = newValue || '100%';
        if (name === 'width') this.width = newValue || '100%';
        this.render();
      }
    
      handleImageLoad() {
        this.isLoaded = true;
        const img = this.shadowRoot.querySelector('img');
        const skeleton = this.shadowRoot.querySelector('fj-skeleton');
    
        if (img) img.classList.add('imageLoaderWrapper__image__visible');
        if (skeleton) skeleton.style.display = 'none';
      }
    
      render() {
        this.shadowRoot.innerHTML = `
        <style>
          :host {
            display: inline-block;
          }
          .imageLoaderWrapper {
            position: relative;
            display: inline-block;
            width: ${this.width};
            height: ${this.height};
                  box-shadow: 4px 4px 0px ${colors$1.primary};

          }
  
          .imageLoaderWrapper__image {
            width: 100%;
            height: 100%;
            object-fit: cover;
            opacity: 0;
            display: block;
            transition: opacity 0.2s ease-in-out;
          }
  
          .imageLoaderWrapper__image__visible {
            opacity: 1;
          }
        </style>
  
        <div class="imageLoaderWrapper">
          <fj-skeleton rect height="${this.height}" width="${this.width}"></fj-skeleton>
          <img
            src="${this.src}"
            alt="${this.alt}"
            height="${this.height}"
            width="${this.width}"
            class="imageLoaderWrapper__image"
          />
        </div>
      `;
    
        const img = this.shadowRoot.querySelector('img');
        img.addEventListener('load', () => this.handleImageLoad());
        img.addEventListener('error', () => this.handleImageLoad());
      }
    }
    
    customElements.define('fj-image-loader', FJImageLoader);

  const { colors, fonts } = theme;

  class FJCarousel extends HTMLElement {
    static get observedAttributes() {
      return ['shownavarrows', 'shownavdots', 'autoslide', 'autoslideinterval', 'slides', 'height', 'width'];
    }

    constructor() {
      super();
      this.attachShadow({ mode: 'open' });

      this.currentIndex = 0;
      this.autoSlideTimer = null;

      this.height = '100%';
      this.width = '100%';
      this.showNavArrows = true;
      this.showNavDots = true;
      this.autoSlide = false;
      this.autoSlideInterval = 3000;
      this.slides = [];
    }

    connectedCallback() {
      this.parseAttributes();
      this.render();
      this.initAutoSlide();
    }

    attributeChangedCallback() {
      this.parseAttributes();
      this.render();
      this.initAutoSlide();
    }

    parseAttributes() {
      this.showNavArrows = this.hasAttribute('shownavarrows') ? this.getAttribute('shownavarrows') !== 'false' : true;
      this.showNavDots = this.hasAttribute('shownavdots') ? this.getAttribute('shownavdots') !== 'false' : true;
      this.autoSlide = this.hasAttribute('autoslide') ? this.getAttribute('autoslide') !== 'false' : false;
      this.autoSlideInterval = parseInt(this.getAttribute('autoslideinterval')) || 3000;
      this.height = this.getAttribute('height') || '100%';
      this.width = this.getAttribute('width') || '100%';

      const slidesAttr = this.getAttribute('slides');
      try {
        this.slides = slidesAttr ? JSON.parse(slidesAttr) : [];
      } catch {
        this.slides = [];
      }

      // Reset index if out of bounds
      if (this.currentIndex >= this.slides.length) {
        this.currentIndex = 0;
      }
    }

    initAutoSlide() {
      clearInterval(this.autoSlideTimer);
      if (this.autoSlide && this.slides.length > 1) {
        this.autoSlideTimer = setInterval(() => this.nextSlide(), this.autoSlideInterval);
      }
    }

    nextSlide() {
      if (!this.slides.length) return;
      this.currentIndex = (this.currentIndex + 1) % this.slides.length;
      this.updateSlidePosition();
    }

    prevSlide() {
      if (!this.slides.length) return;
      this.currentIndex = (this.currentIndex - 1 + this.slides.length) % this.slides.length;
      this.updateSlidePosition();
    }

    goToSlide(index) {
      if (index >= 0 && index < this.slides.length) {
        this.currentIndex = index;
        this.updateSlidePosition();
      }
    }

    updateSlidePosition() {
      const inner = this.shadowRoot.querySelector('.carousel__inner');
      if (inner) {
        inner.style.transform = `translateX(-${this.currentIndex * 100}%)`;
      }
      this.updateDots();
    }

    updateDots() {
      const dots = this.shadowRoot.querySelectorAll('.carousel__dot');
      dots.forEach((dot, index) => {
        dot.classList.toggle('carousel__activeDot', index === this.currentIndex);
      });
    }

    render() {
      if (!this.slides.length) {
        this.shadowRoot.innerHTML = `<style>:host { display: none; }</style>`;
        return;
      }

      this.shadowRoot.innerHTML = `
      <style>
        :host {
          display: block;
          overflow: hidden;
          position: relative;
          height: ${this.height};
          width: ${this.width};
        }
        .carousel {
          height: ${this.height};
          width: ${this.width};
        }
        .carousel__inner {
          display: flex;
          transition: transform 0.5s ease-in-out;
        }
        .carousel__slide {
          min-width: 100%;
          opacity: 0;
          transition: opacity 0.5s ease;
        }
        .carousel__slide.active {
          opacity: 1;
        }
        .carousel__button {
          position: absolute;
          top: 50%;
          transform: translateY(-50%);
          background: rgba(0,0,0,0.5);
          border: none;
          color: white;
          cursor: pointer;
          padding: 0.5em;
                box-shadow: 2px 2px 0px #ccc;

        }
        .carousel__button.prev { left: 10px; }
        .carousel__button.next { right: 10px; }
        .carousel__dots {
          text-align: center;
          margin-top: 10px;
        }
        .carousel__dot {
          display: inline-block;
          width: 10px;
          height: 10px;
          margin: 0 5px;
          background: #aaa;
          cursor: pointer;
          transition: background 0.3s ease;
                box-shadow: 2px 2px 0px #ccc;

        }
        .carousel__activeDot {
          background: ${colors.text};
        }
      </style>

      <div class="carousel">
        <div class="carousel__inner">
          ${this.slides.map((_, index) => `
            <div class="carousel__slide active">
              <fj-image-loader></fj-image-loader>
            </div>
          `).join('')}
        </div>

        ${this.showNavArrows && this.slides.length > 1 ? `
          <button class="carousel__button prev">&#10094;</button>
          <button class="carousel__button next">&#10095;</button>
        ` : ''}

        ${this.showNavDots && this.slides.length > 1 ? `
          <div class="carousel__dots">
            ${this.slides.map((_, index) => `
              <span class="carousel__dot ${index === this.currentIndex ? 'carousel__activeDot' : ''}" data-index="${index}"></span>
            `).join('')}
          </div>
        ` : ''}
      </div>
    `;

      // Now bind image URLs and alt attributes AFTER the shadow DOM is ready:
      const imageElements = this.shadowRoot.querySelectorAll('fj-image-loader');
      imageElements.forEach((img, index) => {
        img.setAttribute('src', this.slides[index]);
        img.setAttribute('alt', `Slide ${index + 1}`);
      });

      // Dot navigation
      this.shadowRoot.querySelectorAll('.carousel__dot').forEach(dot => {
        dot.addEventListener('click', e => this.goToSlide(Number(e.target.dataset.index)));
      });

      // Arrow navigation
      if (this.showNavArrows) {
        this.shadowRoot.querySelector('.carousel__button.prev')?.addEventListener('click', () => this.prevSlide());
        this.shadowRoot.querySelector('.carousel__button.next')?.addEventListener('click', () => this.nextSlide());
      }

      this.updateSlidePosition();
    }
  }

  customElements.define('fj-carousel', FJCarousel);

  class FJAccordion extends HTMLElement {
      static get observedAttributes() {
        return ['title', 'description', 'open', 'toggleIcon', 'border', 'status'];
      }
    
      constructor() {
        super();
        this.attachShadow({ mode: 'open' });
        this.isOpen = false;
      }
    
      connectedCallback() {
        this.parseAttributes();
        this.render();
      }
    
      attributeChangedCallback() {
        this.parseAttributes();
        this.render();
      }
    
      parseAttributes() {
        this.title = this.getAttribute('title') || '';
        this.description = this.getAttribute('description') || '';
        this.isOpen = this.hasAttribute('open') && this.getAttribute('open') !== 'false';
        this.toggleIcon = this.getAttribute('toggleIcon') || '';
        this.border = !this.hasAttribute('border') || this.getAttribute('border') !== 'false';
    
        const statusAttr = this.getAttribute('status');
        try {
          this.status = statusAttr ? JSON.parse(statusAttr) : null;
        } catch {
          this.status = null;
        }
      }
    
      toggle() {
        if (!this.innerHTML.trim()) return;
        this.isOpen = !this.isOpen;
        this.render();
      }
    
      render() {
        this.shadowRoot.innerHTML = `
        <style>

          .collapsible {
            display: flex;
            flex-direction: column;
            transition: 0.3s;
            width: 100%;
          }
  
          .collapsible__border {
            border: 1px solid #aaa;
                  box-shadow: 4px 4px 0px #ccc;

          }
  
          .collapsible__toggle {
            cursor: pointer;
          }
  
          .collapsible__header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            padding: 6px 12px;
          }
  
          .collapsible__header__prefixIcon {
            margin-right: 2%;
            display: flex;
          }
  
          .collapsible__header__text {
            display: flex;
            flex-direction: column;
            gap: 6px;
            width: 100%;
          }
  
          .collapsible__header__title {
            display: flex;
            align-items: center;
            justify-content: flex-start;
            flex-wrap: wrap;
            font-size: 14px;
            gap: 10px;
          }
  
          .collapsible__content {
            overflow: hidden;
            opacity: 0;
            height: 0;
            display: flex;
            flex-direction: column;
          }
  
          .collapsible__content__show {
            overflow: visible;
            opacity: 1;
            transition: ease-in-out, opacity 300ms;
            height: auto;
                        padding: 8px;

          }
  
          .collapsible__content__message {
            padding: 0 20px;
          }
        </style>
  
        <div class="collapsible ${this.border ? 'collapsible__border' : ''}">
          <div class="collapsible__header" aria-expanded="${this.isOpen}" onclick="this.getRootNode().host.toggle()">
  
            <div class="collapsible__header__text">
              <div class="collapsible__header__title">
                <fj-text semiBold>${this.title}</fj-text>
                ${this.status ? `<fj-chip type="${this.status.type}">${this.status.text}</fj-chip>` : ''}
              </div>
              ${this.description ? `<fj-text type="label">${this.description}</fj-text>` : ''}
            </div>
  
            ${this.innerHTML.trim() !== '' ? `
              <div class="collapsible__toggle">
                ${this.toggleIcon ? `<img src="${this.toggleIcon}" height="16" />`
                  : `<span>${this.isOpen ? '▲' : '▼'}</span>`}
              </div>` : ''
            }
          </div>
  
          <div class="collapsible__content ${this.isOpen ? 'collapsible__content__show' : ''}">
            <slot></slot>
          </div>
        </div>
      `;
      }
    }
    
    customElements.define('fj-accordion', FJAccordion);

})();
